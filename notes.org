#+PROPERTY: header-args :exports code

* [[https://www.braveclojure.com/getting-started/][Building, Running, and the REPL]]
** [[https://www.braveclojure.com/getting-started/#First_Things_First__What_Is_Clojure_][First Things First: What is Clojure?]]
   * A Lisp dialect
   * Functional paradigm
   * Strong support for concurrency and other complicated domains
   * Hosted language - runs on the JVM and relies on threading, garbage collection, other features
   * JVM running Clojure process executes JVM bytecode generated by the same process
** [[https://www.braveclojure.com/getting-started/#Leiningen][Leiningen]]
   * Used to build and manage Clojure projects
*** [[https://www.braveclojure.com/getting-started/#Creating_a_New_Clojure_Project][Creating a New Clojure Project]]
#+BEGIN_SRC sh
lein new app clojure-noob
#+END_SRC
    * Creates a new Clojure project named ~clojure-noob~
    * The ~project.clj~ file defines project metadata, including dependencies and the main function
*** [[https://www.braveclojure.com/getting-started/#Running_the_Clojure_Project][Running the Clojure Project]]
#+BEGIN_SRC clojure
(ns clojure-noob.core
  (:gen-class))

(defn -main
  "I don't do a whole lot...yet"
  [& args]
  (println "I'm a little teapot!"))
#+END_SRC
    * Declares a namespace named ~clojure-noob.core~ and a function ~-main~, the program's entry point
#+BEGIN_SRC sh
lein run
#+END_SRC
    * Runs the Clojure project described by the ~project.clj~ file in the current working directory
*** [[https://www.braveclojure.com/getting-started/#Building_the_Clojure_Project][Building the Clojure Project]]
#+BEGIN_SRC sh
lein uberjar
#+END_SRC
    * Creates JAR files at ~target/uberjar/name-version.jar~ and ~name-version-standalone.jar~
*** [[https://www.braveclojure.com/getting-started/#Using_the_REPL][Using the REPL]]
    * Stands for Read Eval Print Loop
      * Read input, evaluate it, print the output, and repeat
    * Tool for code experimentation and quick feedback cycle
    * Allows interacting with or modifying running code
#+BEGIN_SRC sh
lein repl
#+END_SRC
    * Starts a Clojure REPL and prompts the user with ~<namespace>=>~
      * Code from the current project is available to use
    * Lisps use prefix notation, so an operator precedes its operands
** [[https://www.braveclojure.com/getting-started/#Clojure_Editors][Clojure Editors]]
* [[https://www.braveclojure.com/basic-emacs/][How to Use Emacs, an Excellent Clojure Editor]]
  * Provides strong REPL integration
  * Great for programming in any Lisp
** [[https://www.braveclojure.com/basic-emacs/#Installation][Installation]]
** [[https://www.braveclojure.com/basic-emacs/#Configuration][Configuration]]
** [[https://www.braveclojure.com/basic-emacs/#Emacs_Escape_Hatch][Emacs Escape Hatch]]
   * Run ~C-g~ to cancel the current action
** [[https://www.braveclojure.com/basic-emacs/#Emacs_Buffers][Emacs Buffers]]
   * Editing occurs in buffers
   * ~*scratch*~ is the default buffer
   * Create or change to a buffer with ~C-x b~
   * A minibuffer is used for input
   * Kill a buffer with ~C-x k~
** [[https://www.braveclojure.com/basic-emacs/#Working_with_Files][Working with Files]]
   * Open or create a file with ~C-x C-f~
   * Save a file with ~C-x C-s~
** [[https://www.braveclojure.com/basic-emacs/#Key_Bindings_and_Modes][Key Bindings and Modes]]
*** [[https://www.braveclojure.com/basic-emacs/#Emacs_Is_a_Lisp_Interpreter][Emacs is a Lisp Interpreter]]
    * Emacs binds keystrokes to commands, which are elisp functions
*** [[https://www.braveclojure.com/basic-emacs/#Modes][Modes]]
    * A mode is a group of key bindings, functions, configurations, etc. for editing a given file type
    * Major modes often specialize Emacs for a file type
    * Minor modes often add ubiquitous functionality
    * One major mode and infinite minor modes can be enabled at once
    * ~M-x mode-name~ enables the given mode
*** [[https://www.braveclojure.com/basic-emacs/#Installing_Packages][Installing Packages]]
    * Modes are distributed as packages, which are collections of elisp files in a repository
    * ~M-x package-refresh-list~ refreshes the package list
    * ~M-x package-list-packages~ lists the enabled packages
    * ~M-x package-install package-name~ installs a given package
** [[https://www.braveclojure.com/basic-emacs/#Core_Editing_Terminology_and_Key_Bindings][Core Editing Terminology and Key Bindings]]
*** [[https://www.braveclojure.com/basic-emacs/#Point][Point]]
    * Location of the cursor
    * ~C-/~ undoes the last command
*** [[https://www.braveclojure.com/basic-emacs/#Movement][Movement]]
| Command | Description                                 |
|---------+---------------------------------------------|
| ~C-a~   | Move to the start of the line               |
| ~C-e~   | Move to the end of the line                 |
| ~C-f~   | Move forward by one character               |
| ~C-b~   | Move backwards by one character             |
| ~M-f~   | Move forward by one word                    |
| ~M-b~   | Move backwards by one word                  |
| ~C-s~   | Reged search forward; repeat for next match |
| ~C-r~   | ~C-s~ but in reverse                        |
| ~M-<~   | Move to the start of the buffer             |
| ~M->~   | Move to the end of the buffer               |
| ~M-g-g~ | Go to to a line                             |
*** [[https://www.braveclojure.com/basic-emacs/#Selection_with_Regions][Selection with Regions]]
    * Text is not selected, instead regions are created
    * ~C-SPC~ sets the mark for the region
    * Regions allow standard movement commands to be used once the mark is set
    * Regions limit the span of operations
    * ~M-x replace-string~ repalces a given string with another
*** [[https://www.braveclojure.com/basic-emacs/#Killing_and_the_Kill_Ring][Killing and the Kill Ring]]
    * Kill ring stores multiple cyclable blocks of text, making it more powerful than the clipboard
| Command | Description                                              |
|---------+----------------------------------------------------------|
| ~C-w~   | Kill a region                                            |
| ~M-w~   | Save to the kill ring without killing (essentially copy) |
| ~C-y~   | Yank                                                     |
| ~M-y~   | Cycle through the kill ring after yanking                |
| ~M-d~   | Kill a word                                              |
| ~C-k~   | Kill a line                                              |
*** [[https://www.braveclojure.com/basic-emacs/#Editing_and_Help][Editing and Help]]
| Command             | Description                                                       |
|---------------------+-------------------------------------------------------------------|
| ~C-j~               | Create a new line and indent it                                   |
| ~M-/~               | Cycles through possible expansions of the text before point       |
| ~M-/~               | Deletes whitespace around point                                   |
| ~C-h k key-binding~ | Show documentation for the function bound to the given keybinding |
| ~C-h f~             | Show documentation for a given function                           |
** [[https://www.braveclojure.com/basic-emacs/#Using_Emacs_with_Clojure][Using Emacs with Clojure]]
*** [[https://www.braveclojure.com/basic-emacs/#Fire_Up_Your_REPL_][Fire Up Your REPL!]]
    * ~M-x cider-jack-in~ initializes a REPL
*** [[https://www.braveclojure.com/basic-emacs/#Interlude__Emacs_Windows_and_Frames][Interlude: Emacs Windows and Frames]]
    * A frame is what is usually called a window
    * Frames can hold multiple windows, which allows viewing multiple buffers at once
| Command | Description                                              |
|---------+----------------------------------------------------------|
| ~C-x o~ | Switch the cursor to the other window                    |
| ~C-x 1~ | Deletes all windows except for the currently focused one |
| ~C-x 2~ | Splits the current frame top and bottom                  |
| ~C-x 3~ | Splits the current frame side by side                    |
| ~C-x 0~ | Deletes the current window                               |
*** [[https://www.braveclojure.com/basic-emacs/#A_Cornucopia_of_Useful_Key_Bindings][A Cornucopia of Useful Key Bindings]]
    * Namespaces organize code to prevent naming conflicts
| Command         | Description                                                               |
|-----------------+---------------------------------------------------------------------------|
| ~C-c M-n M-n~   | Change the current REPL namespace to that of the current buffer           |
| ~C-x C-e~       | Evaluate the expression before point                                      |
| ~C-u C-x C-e~   | ~C-x C-e~ and print the result at point                                   |
| ~C-c C-k~       | Compile the current buffer                                                |
| ~C-c C-d C-d~   | Show documentation for the symbol at point                                |
| ~M-.~ and ~M-,~ | Goto the source for the symbol at point and return to the original buffer |
| ~C-c C-d C-a~   | Arbitrarily search across function names and documentation                |

| Command     | Description                                                                   |
|-------------+-------------------------------------------------------------------------------|
| ~C-up/down~ | Move through REPL history                                                     |
| ~C-RET~     | Close open parentheses and brackets in the current expression and evaluate it |
*** [[https://www.braveclojure.com/basic-emacs/#How_to_Handle_Errors][How to Handle Errors]]
    * CIDER displays a stack trace in a buffer when an attempt is made to compile or evaluate broken code
      * The trace can be filtered for Clojure, Java, REPL, Tooling, and Duplicates
    * Stack traces show which function bore an error and which function called that function, etc.
    * Use ~q~ to exit the stack trace buffer
*** [[https://www.braveclojure.com/basic-emacs/#Paredit][Paredit]]
    * Minor mode to automatically close paired punctuation
    * Allows navigating and modifying paired punctuation easily
    * [[https://github.com/georgek/paredit-cheatsheet/blob/master/paredit-cheatsheet.pdf][Cheatsheet]]
**** [[https://www.braveclojure.com/basic-emacs/#Wrapping_and_Slurping][Wrapping and Slurping]]
     * Use ~M-(~ to wrap, which surrounds the expression following point with parentheses
     * Use ~C-right~ to slurp, which includes the next expression to the right inside the parentheses
**** [[https://www.braveclojure.com/basic-emacs/#Barfing][Barfing]]
     * Use ~C-left~ to barf, which is the opposite of slurping
**** [[https://www.braveclojure.com/basic-emacs/#Navigation][Navigation]]
     * Use ~C-M-f~ and ~C-M-b~ to move to the closing/opening parenthesis when point is before/after the opening/closing parenthesis
* [[https://www.braveclojure.com/do-things/][Do Things: A Clojure Crash Course]]
** [[https://www.braveclojure.com/do-things/#Syntax][Syntax]]
*** [[https://www.braveclojure.com/do-things/#Forms][Forms]]
    * Clojure has a uniform structure like other Lisps
      * Valid structures are either data structure literals or operations
    * A form is valid code that is evaluated as an expression
#+BEGIN_SRC clojure
(operator operand1 operand2 ... operandn)
#+END_SRC
    * The general form for an operation
    * Any type of whitespace, which for Clojure includes commas, can separate operands
    * src_clojure{+} adds its operands as numbers
*** [[https://www.braveclojure.com/do-things/#Control_Flow][Control Flow]]
**** [[https://www.braveclojure.com/do-things/#if][if]]
#+BEGIN_SRC clojure
(if boolean-form
  then-form
  optional-else-form)
#+END_SRC
     * The general form for an if-expression
     * A boolean form evaluates to a truthy or falsey value
       * src_clojure{true} and src_clojure{false} are the fundamental truthy and falsey values
     * If the else form is left out and the boolean form is falsey, src_clojure{nil} is returned
**** [[https://www.braveclojure.com/do-things/#do][do]]
     * Evaluates all forms passed to it
     * Can be used to evaluate multiple forms in each branch of an if-expression
**** [[https://www.braveclojure.com/do-things/#when][when]]
     * If the first form passed is truthy, evaluates the rest of the forms, otherwise returns src_clojure{nil}
     * Essentially a combo of src_clojure{if} and src_clojure{do} without an else form
**** [[https://www.braveclojure.com/do-things/#nil__true__false__Truthiness__Equality__and_Boolean_Expressions][nil, true, false, Truthiness, Equality, and Boolean Expressions]]
     * src_clojure{nil} indicates the lack of a value
     * src_clojure{nil?} checks if a given vaue is src_clojure{nil} or not
     * src_clojure{nil} and src_clojure{false} are the only falsey values; all other values are truthy
     * src_clojure{=} is the equality operator and compares all of its operands
     * src_clojure{or} returns its first truthy operand or, if none are present, its last operand
       * src_clojure{(or)} returns src_clojure{nil}
     * src_clojure{and} returns its first falsey operand, or, if none are present, its last truthy operand
       * src_clojure{(and)} returns src_clojure{true}
*** [[https://www.braveclojure.com/do-things/#Naming_Values_with_def][Naming Values with def]]
    * src_clojure{def} binds a name to a value
    * Mutating name-value bindings is discouraged, in line with Clojure's functional paradigm
#+BEGIN_SRC clojure
(def name value)
#+END_SRC
    * The general form for a src_clojure{def} expression
** [[https://www.braveclojure.com/do-things/#Data_Structures][Data Structures]]
   * Clojure's data structures are immutable and cannot be changed in-place
*** [[https://www.braveclojure.com/do-things/#Numbers][Numbers]]
    * Longs, floats, and ratios are supported
#+BEGIN_SRC clojure
93
1.2
1/5
#+END_SRC
    * Literal forms for a long, a float, and a ratio
*** [[https://www.braveclojure.com/do-things/#Strings][Strings]]
    * Represent text
    * Enclosed within paired src_clojure{"}s
    * Use the src_clojure{str} function to concatenate strings
*** [[https://www.braveclojure.com/do-things/#Maps][Maps]]
    * Associate values to other values
    * Clojure has hash maps and sorted maps
#+BEGIN_SRC clojure
{}
{"a" "b"}
#+END_SRC
    * An empty hash map literal and a hash map literal with one key-value pair
    * src_clojure{hash-map} creates a hash map from its operands (each pair of operands is an association)
#+BEGIN_SRC clojure
(get {:a 0 :b 1} :b) ; => 1
(get {:a 0 :b 1} :c) ; => nil
(get {:a 0 :b 1} :c 3) ; => 3
#+END_SRC
    * src_clojure{get} retrieves a value or returns src_clojure{nil} or a provided default if no value can be found
#+BEGIN_SRC clojure
(get-in {:a 0 :b {:c 3}} [:b :c]) ; => 3
#+END_SRC
    * src_cljoure{get-in} retrieves a value from a nested map
#+BEGIN_SRC clojure
({:a 0 :b 1} :b) ; => 1
#+END_SRC
    * Maps can be used as functions to retrieve values
*** [[https://www.braveclojure.com/do-things/#Keywords][Keywords]]
    * Often used as map keyes
#+BEGIN_SRC clojure
(:b {:a 0 :b 1}) ; => 1
(:c {:a 0 :b 1} 3) ; => 3
#+END_SRC
    * Keywords, if used for keys, can be used as functions to retrieve values
      * Default values supported
*** [[https://www.braveclojure.com/do-things/#Vectors][Vectors]]
    * Zero-indexed ordered collection
#+BEGIN_SRC clojure
[1 2 3]
#+END_SRC
    * A vector literal
    * src_clojure{get} retrieves values from a vector by index
    * src_clojure{vector} creates a vector from its operands
#+BEGIN_SRC clojure
(conj [1 2 3] 4) ; => [1 2 3 4]
#+END_SRC
    * src_clojure{conj} adds an element to the end of a vector
*** [[https://www.braveclojure.com/do-things/#Lists][Lists]]
    * Zero-indexed ordered collection
#+BEGIN_SRC clojure
'(1 2 3)
#+END_SRC
    * A list literal
    * src_clojure{nth} is used to retrieve values by index, not src_clojure{get}
      * An optional default value can be provided as the last operand
      * src_clojure{nth} for lists is slower than src_clojure{get} for vectors because lists are singly linked lists
    * src_clojure{list} creates a list from its operands
#+BEGIN_SRC clojure
(conj '(1 2 3) 4) ; => (4 1 2 3)
#+END_SRC
    * src_clojure{conj} prepends to a list
    * Good for macros or prepending elements; otherwise a vector is likely the right choice
*** [[https://www.braveclojure.com/do-things/#Sets][Sets]]
    * Unordered collecction of unique values
#+BEGIN_SRC clojure
#{:a :b :c}
#+END_SRC
    * A set literal
    * src_clojure{hash-set} creates a hash set from its operands
    * Adding a pre-existing element to a set does nothing
    * src_clojure{set} creates a set from an existing vector or list
      * If a map is passed, the returned set is one of vectors, where each contains an association
    * src_clojure{contains?} checks for set membership
    * src_clojure{get} or a keyword can be used to test for set membership
      * The value is returned if it exists, otherwise src_clojure{nil} is returned
*** [[https://www.braveclojure.com/do-things/#Simplicity][Simplicity]]
    * Using built-in data structures is encouraged over creating new types or classes
      * Improves code reusability and simplicity
** [[https://www.braveclojure.com/do-things/#Functions][Functions]]
*** [[https://www.braveclojure.com/do-things/#Calling_Functions][Calling Functions]]
    * A function call is an operation where the operator is a function or function expression
    * Higher-order functions take functions as arguments or return functions
      * Allows abstraction over processes rather than just over values
    * If a langauge supports first-class functions, functions can be treated as values just like other data
#+BEGIN_SRC clojure
(map inc [0 1 2 3]) ; => (1 2 3 4)
#+END_SRC
    * src_clojure{inc} increments its operand by src_clojure{1}
    * src_clojure{map} returns a list where each element is the result of applying a given function to every element of a given collection
    * Function arguments are evaluated recursively before being passed to a function
*** [[https://www.braveclojure.com/do-things/#Function_Calls__Macro_Calls__and_Special_Forms][Function Calls, Macro Calls, and Special Forms]]
    * As opposed to function calls, macro calls and special forms also exist
    * Definitions and src_clojure{if} are both special forms
    * Special forms don't always evaluate all of their operands and they cannot be used as function arguments
    * The few special forms that exist generally implement core language functionality that cannot be replicated with functions
    * Macros also evaluate their operands differently and cannot be passed as arguments to functions
*** [[https://www.braveclojure.com/do-things/#Defining_Functions][Defining Functions]]
    * Function definitions include src_clojure{defn}, the function name, an optional docstring, the parameters, and the body
#+BEGIN_SRC clojure
(defn too-enthusiastic
  "Return a cheer that might be a bit too enthusiastic"
  [name]
  (str "OH. MY. GOD! " name " YOU ARE MOST DEFINITELY LIKE THE BEST "
  "MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE"))
#+END_SRC
    * Defines a function named src_clojure{too-enthusiastic} with a docstring that takes a single argument src_clojure{name} and returns a string
**** [[https://www.braveclojure.com/do-things/#The_Docstring][The Docstring]]
     * Describes and documents code
     * src_clojure{(doc fn-name)} will display a function's docstring when run in the REPL
**** [[https://www.braveclojure.com/do-things/#Parameters_and_Arity][Paramters and Arity]]
     * A function's arity is the number of parameters it accepts as input
     * Arguments are passed to functions
     * Functions can have any arity
     * An /n/-arity function accepts n parameters
     * Clojure supports arity overloading, wherein different code bodies are executed depending on the number of arguments passed to a function
#+BEGIN_SRC clojure
(defn multi-arity
  ([first-arg second-arg third-arg]
     (do-things first-arg second-arg third-arg))
  ([first-arg second-arg]
     (do-things first-arg second-arg))
  ([first-arg]
     (do-things first-arg)))
#+END_SRC
     * A function with arity overloading that has 1-arity, 2-arity, and 3-arity bodies
       * Each body is within its own form and has its own argument list
     * Arity overloading can be used to supply default arguments
       * The body of (/n - 1/)-arity calls the body of /n/-arity, passing a default value for the missing parameter
     * Functions can be of variable arity using a /rest/ parameter indicated by an src_clojure{&}
#+BEGIN_SRC clojure
(defn print-args
  [& args]
  (reduce str args))
#+END_SRC
     * src_clojure{args} is a rest parameter that holds any arguments not bound to other parameters (in this case no other parameters exist)
       * Binding is performed positionally
     * Rest parameters must be the last parameter but can also be the only parameter
     * Rest parameters behave as lists
**** [[https://www.braveclojure.com/do-things/#Destructuring][Destructuring]]
     * Allows concise name-value binding to values in a collection
     * Destructure a vector into parameters by placing a vector of parameters inside the parameter list
#+BEGIN_SRC clojure
(defn func
  [[a b c & rest]]
  (str a b c args))
#+END_SRC
     * Defines a function whose first parameter, a vector or list, is destructured into three parameters and a rest parameter
     * Destructure a map into parameters by placing a map of parameter-key assocations into the parameter list
#+BEGIN_SRC clojure
(defn func
  [{a :a b :b}]
  (str a b))
#+END_SRC
    * Defines a function whose first parameter, a map, is destructured into two parameters
#+BEGIN_SRC clojure
(defn func
  [{:keys [a b]}]
  (str a b))
#+END_SRC
    * The equivalent, using shorthand for turning keywords from a map into parameters
    * To retain the original map as a parameter, put src_clojure{:as map-parameter-name} into the destructuring
**** [[https://www.braveclojure.com/do-things/#Function_Body][Function Body]]
     * The return value of a function body is the value of its last form
**** [[https://www.braveclojure.com/do-things/#All_Functions_Are_Created_Equal][All Functions Are Created Equal]]
     * No functions are "special" or "privileged" in Clojure
     * All functions are treated the same way in Clojure
*** [[https://www.braveclojure.com/do-things/#Anonymous_Functions][Anonymous Functions]]
    * A nameless function
    * The general form for an anonymous function is src_clojure{(fn [param list] body)}
    * Excepting the lack of  aname, they are completely equivalent to functions named with src_clojure{defn}
      * src_clojure{defn} actually relies on src_clojure{def} and src_clojure{fn}, so anonymous and named functions have no differences
#+BEGIN_SRC clojure
(fn [n] (* n 3))
#+END_SRC
    * An anonymous function
    * The compact form for an anonymous function is src_clojure{#(body)} where src_clojure{%} /n/ can be used for the /nth/ parameter and src_clojure{%} is the first parameter
      * Use src_clojure{%&} for a rest parameter
      * Made possible by reader macros
      * Good for short and simple functions, not for longer or more complex ones
#+BEGIN_SRC clojure
#(* % 3)
#+END_SRC
    * The same anonymous function written in a more compact form
    * src_clojure{identity} returns its argument
*** [[https://www.braveclojure.com/do-things/#Returning_Functions][Returning Functions]]
    * Functions can return other functions since functions are just values
    * Those returned functions, and any other functions made inside another function, are closures and can access all variables in the scope of their containing function
** [[https://www.braveclojure.com/do-things/#Pulling_It_All_Together][Pulling it All Together]]
*** [[https://www.braveclojure.com/do-things/#The_Shire_s_Next_Top_Model][The Shire's Next Top Model]]
*** [[https://www.braveclojure.com/do-things/#let][let]]
    * src_clojure{let} binds names to values within a new scope
#+BEGIN_SRC clojure
(let [name value] body)
#+END_SRC
    * The general structure for a src_clojure{let}-expression
    * src_clojure{set} returns a set of unique elements from the collection passed to it
    * src_clojure{into} returns the result of adding an element, its second operand, to a collection, its first operand
*** [[https://www.braveclojure.com/do-things/#loop][loop]]
    * Allows recursion in Clojure, with name bindings as the first argument
    * src_clojure{recur} results in a recursive call and takes as many arguments as its recursion point does
    * Has better performance than normal recursive functions
*** [[https://www.braveclojure.com/do-things/#Regular_Expressions][Regular Expressions]]
    * Allow pattern matching text
    * Literal notation is src_clojure{#"pattern"}
    * src_clojure{clojure.string/replace} can take a matcher regex and replacement string as arguments
    * src_clojure{re-find} takes a regex and a string, returning the matched text or src_clojure{nil} if none was found
*** [[https://www.braveclojure.com/do-things/#Symmetrizer][Symmetrizer]]
    * Splitting a list into its head and tail (first element and remaining elements), processing the head, and recursively progressing through the list is a common pattern
*** [[https://www.braveclojure.com/do-things/#Better_Symmetrizer_with_reduce][Better Symmetrizer with reduce]]
    * src_clojure{reduce} processes a collection into a new value by
      * Applying the function to the collection's first two elements
      * Applying the function to that result and the next element and repeating this for all elements
    * An optional initial value can be supplied after the function, in which case the function is first applied to that value and the collection's first element
#+BEGIN_SRC clojure
(reduce + list)
#+END_SRC
    * Sum the elements of a list
*** [[https://www.braveclojure.com/do-things/#Hobbit_Violence][Hobbit Violence]]
    * src_clojure{rand} returns a float on the interval [0, /n/), where /n/ defaults to 1
* [[https://braveclojure.com/core-functions-in-depth][Core Functions in Depth]]
** [[https://www.braveclojure.com/core-functions-in-depth/#Programming_to_Abstractions][Programming to Abstractions]]
   * A single function often works with many types by programming to abstractions
     * Maps, lists, vectors, and sets can behave as sequences (i.e. respond to sequence operations) and thus work with many functions
*** [[https://www.braveclojure.com/core-functions-in-depth/#Treating_Lists__Vectors__Sets__and_Maps_as_Sequences][Treating Lists, Vectors, Sets, and Maps as Sequences]]
    * Clojure is designed to allow programming and thinking in terms of abstractions rather than concrete things
    * Sequence functions can be used for lists, vectors, sets, maps, and any other data structures that work as sequences, without care for the specific type
      * Data structures that work with src_clojure{first}, src_clojure{rest}, and src_clojure{cons} implement the sequence abstraction
*** [[https://www.braveclojure.com/core-functions-in-depth/#first__rest__and_cons][first, rest, and cons]]
    * Linked lists are linear sequences of nodes pointing to the next node in the sequence
    * src_clojure{first} returns the first element of a given list
    * src_clojure{rest} returns a list containing every element but the first of a given list
    * src_clojure{cons} prepends a given element to a given list
*** [[https://www.braveclojure.com/core-functions-in-depth/#Abstraction_Through_Indirection][Abstraction Through Indirection]]
    * Indirection is the set of mechanisms that permit referencing something via something else rather than the thing itself
      * Permits abstraction - a single function may execute slightly different code depending on the type(s) of its operand(s)
    * Polymorphism, a form of indrection, is where a function dispatches to different implementations based on argument types
    * Using lightweight type conversion (e.g. with the src_clojure{seq} conversion function) provides some indirection by converting arguments into types that may be easier to work with
** [[https://www.braveclojure.com/core-functions-in-depth/#Seq_Function_Examples][Seq Function Examples]]
*** [[https://www.braveclojure.com/core-functions-in-depth/#map][map]]
    * src_clojure{map} takes a function and any number of collections, returning a new one by applying the function to the corresponding elements in each collection
    * One use case is to pass a higher-order function operating on some data and a collection of functions to perform multiple operations on the data
    * Another use case is to pull values associated with a particular keyword from a collection of maps
*** [[https://www.braveclojure.com/core-functions-in-depth/#reduce][reduce]]
    * src_clojure{reduce} is useful for many cases of creating a new value from a collection
    * One use case is to create a new map with updated values from an initial map
    * Another use case is for filtering out map pairs
*** [[https://www.braveclojure.com/core-functions-in-depth/#take__drop__take_while__and_drop_while][take, drop, take-while, and drop-while]]
    * src_clojure{take} and src_clojure{drop} take a number and a collection
      * The number is the amount of elements to keep or remove from the beginning, respectively
    * src_clojure{take-while} and src_clojure{drop-while} take a predicate and a collection and keep or remove elements until the predicate returns src_clojure{false}
*** [[https://www.braveclojure.com/core-functions-in-depth/#filter_and_some][filter and some]]
    * src_clojure{filter} takes a predicate and collection and returns a new collection containing every element satisfying the predicate
    * src_clojure{some} takes a predicate and a collection and returns the first truthy value returned by the predicate or src_clojure{nil}
*** [[https://www.braveclojure.com/core-functions-in-depth/#sort_and_sort_by][sort and sort-by]]
    * src_clojure{sort} sorts a collection in ascending order
    * src_clojure{sort-by} takes a key function and a collection and sorts it by the sort order of the elements returned by the key function, which transforms collection values into new values
*** [[https://www.braveclojure.com/core-functions-in-depth/#concat][concat]]
    * src_clojure{concat} concatenates multiple sequences together into one sequence
** [[https://www.braveclojure.com/core-functions-in-depth/#Lazy_Seqs][Lazy Seqs]]
   * A lazy sequence's elements are not computed until necessary, such as when explicitly accessed
     * /Realizing/ a lazy sequence is computing its values
   * Lazy sequences can improve efficiency and facilitate infinite sequences
*** [[https://www.braveclojure.com/core-functions-in-depth/#Demonstrating_Lazy_Seq_Efficiency][Demonstrating Lazy Seq Efficiency]]
    * src_clojure{time} evaluates a given form, prints the time taken to evaluate, and returns the forms' return value
    * Lazy sequences are chunked, so when one element is realized, a certain amount of elements following it will be preemptively realized
    * Time or memory intensive tasks can be prevented, run fewer times, or delayed by lazily evaluating sequences
*** [[https://www.braveclojure.com/core-functions-in-depth/#Infinite_Sequences_][Infinite Sequences]]
    * Lazy sequences without specific endpoints are infinite sequences
    * src_clojure{repeat} creates an infinite sequence of a given element
    * src_clojure{repeatedly} creates an infinite sequence by invoking a given function
** [[https://www.braveclojure.com/core-functions-in-depth/#The_Collection_Abstraction][The Collection Abstraction]]
   * Vectors, maps, lists, and sets satisfy both the sequence and collection abstractions
   * The collection abstraction relates to thet entire collection as opposed to individual elements
   * src_clojure{count} returns the number of elements in a given collection
   * src_clojure{empty?} returns whether or not a given collection is empty
   * src_clojure{every?} returns whether every element in a given collection satisfies a given predicate
*** [[https://www.braveclojure.com/core-functions-in-depth/#into][into]]
    * src_clojure{into} takes two collections as arguments and conjoins the elements of the second into the first
    * A good use case is turning sequences derived from collections back into the original collection type
*** [[https://www.braveclojure.com/core-functions-in-depth/#conj][conj]]
    * src_clojure{conj} takes a collection and any number of elements and conjoins the elements into the collection
    * src_clojure{conj} is essentially equivalent to src_clojure{into} except the former takes a rest parameter while the latter takes a collection
** [[https://www.braveclojure.com/core-functions-in-depth/#Function_Functions][Function Functions]]
*** [[https://www.braveclojure.com/core-functions-in-depth/#apply][apply]]
    * src_clojure{apply} applies to a given function any number of given values and the contents of a given sequence
*** [[https://www.braveclojure.com/core-functions-in-depth/#partial][partial]]
    * src_clojure{partial} curries a given function and some arguments, returning a new function that can be invoked with the remaining necessary arguments (if any)
    * One use case is creating specialized functions if particular arguments are often passed to some function
*** [[https://www.braveclojure.com/core-functions-in-depth/#complement][complement]]
    * src_clojure{complement} returns a function whose return value is the negation of a given function's return value
** [[https://www.braveclojure.com/core-functions-in-depth/#A_Vampire_Data_Analysis_Program_for_the_FWPD][A Vampire Data Analysis Program for the FWPD]]
   * src_clojure{slurp} returns the contents of a file, located by a given name, as a string
* [[https://www.braveclojure.com/functional-programming/][Functional Programming]]
** [[https://www.braveclojure.com/functional-programming/#Pure_Functions__What_and_Why][Pure Functions: What and Why]]
   * Pure functions are referentially transparent - calls with the same arguments yield the same results
   * Pure functions leave no side effects - no changes are observable from outside of the function
   * Pure functions aid in reasoning about code because they are consistent and wholly isolated
*** [[https://www.braveclojure.com/functional-programming/#Pure_Functions_Are_Referentially_Transparent][Pure Functions Are Referentially Transparent]]
    * Pure functions use only their own arguments and immutable values when forming a return value
    * Functions that rely on impure functions are thereby impure
*** [[https://www.braveclojure.com/functional-programming/#Pure_Functions_Have_No_Side_Effects][Pure Functions Have No Side Effects]]
    * Side effects are necessary but create uncertainty and should be limited in their scope and effects
    * Functions that rely on side effects are thereby impure
    * Immutability prevents side effects
** [[https://www.braveclojure.com/functional-programming/#Living_with_Immutable_Data_Structures][Living with Immutable Data Structures]]
*** [[https://www.braveclojure.com/functional-programming/#Recursion_Instead_of_for_while][Recursion Instead of for/while]]
    * New scopes are needed for names to be bound to different values
      * Recursion is one technique for this - each call in the chain creates a new scope
    * src_clojure{recur} should be used rather than explicit recursion to prevent stack overflows
    * Clojure uses persistent data structures, which use structural sharing to reduce their memory footprint
*** [[https://www.braveclojure.com/functional-programming/#Function_Composition_Instead_of_Attribute_Mutation][Function Composition Instead of Attribute Mutation]]
    * Function composition is the act of passing one function's return value as an argument to another
      * It's similar to recursion, except for recursion both functions are the same
    * Functional programming encourages creating complex functions by combining and composing simpler ones
    * Decoupling functions from data and programming to a few abstractions creates reusable and composable code
    * Functional programming involves manipulating data by way of deriving new data from old data
** [[https://www.braveclojure.com/functional-programming/#Cool_Things_to_Do_with_Pure_Functions][Cool Things to Do with Pure Functions]]
*** [[https://www.braveclojure.com/functional-programming/#comp][comp]]
    * Composing pure functions is entirely safe because only their input/output relationship matters
    * src_clojure{comp} creates a new function by composing any number of given functions from right to left
#+BEGIN_SRC clojure
((comp inc *) 2 3) ; => 7
#+END_SRC
    * Functions are applied right to left, with the rightmost function receiving the input arguments, while each function afterwards receives only the preceding result
    * If a composed function other than the rightmost needs multiple arguments, it can be partialized or wrapped in a 1-arity anonymous function
*** [[https://www.braveclojure.com/functional-programming/#memoize][memoize]]
    * Memoizing a function involves storings its input-output pairs so that calls with the same arguments can return immediately without recomputing the same result
      * Since pure functions are referentially transparent, substituting a computation for its result has no effects on program behavior
      * Memoization trades time for space and is thus useful for computationally expensive functions
    * src_clojure{memoize} returns a memoized version of a given function
** [[https://www.braveclojure.com/functional-programming/#Peg_Thing][Peg Thing]]
*** [[https://www.braveclojure.com/functional-programming/#Playing][Playing]]
*** [[https://www.braveclojure.com/functional-programming/#Code_Organization][Code Organization]]
*** [[https://www.braveclojure.com/functional-programming/#Creating_the_Board][Creating the Board]]
    * src_clojure{assoc-in} is similar to src_clojure{get-in}, except it associates rather than retrieves keys with values in nested maps
    * Reducing over a sequence of functions and applying them to progressively updated values is another technique for function composition
*** [[https://www.braveclojure.com/functional-programming/#Moving_Pegs][Moving Pegs]]
#+BEGIN_SRC clojure
(if-let [foo :bar] foo :baz) ; => :bar
#+END_SRC
    * src_clojure{if-let} combines if and let expressions by creating one binding, the truthiness of which is the test clause
    * A src_clojure{?} at the end of a function name often indicates it to be a predicate function
    * src_clojure{not-empty} returns a given collection if it is not empty and src_clojure{nil} otherwise
*** [[https://www.braveclojure.com/functional-programming/#Rendering_and_Printing_the_Board][Rendering and Printing the Board]]
    * src_clojure{doseq} allows performing side-effects with each element in a collection by binding a name to each successive element in a collection
*** [[https://www.braveclojure.com/functional-programming/#Player_Interaction][Player Interaction]]
* [[https://www.braveclojure.com/organization/][Organizing Your Project: A Librarian's Tale]]
** [[https://www.braveclojure.com/organization/#Your_Project_as_a_Library][Your Project as a Library]]
   * A namespace is an association between symbols (identifiers) and vars (references)
   * src_clojure{*ns*} refers to the current namespace
   * src_clojure{ns-name} returns the name of a given namespace
   * Quoting a form (single quote) prevents it from being evaluated
     * Quoting a symbol yields the symbol itself instead of the var it refers to
#+BEGIN_SRC clojure
'map ; => map
#+END_SRC
** [[https://www.braveclojure.com/organization/#Storing_Objects_with_def][Storing Objects with def]]
   * src_clojure{def} interns vars, or updates symbol-var associations in the current namespace
     * A symbol is mapped to a var, which stores the address of some desired value
   * src_clojure{ns-interns} returns a map of the symbol-var associations of a given namespace
   * src_clojure{ns-map} returns an even more comprehensive map that a given namespace uses for lookups, including associations from referred namespaces
   * A symbol prepended with src_clojure{#'} is the /reader form/ of the var associated with the symbol
   * src_clojure{deref} dereferences a given var and yields the object associated with it
   * Name collision is when a binding overwrites a previous one
     * Prevented by organizing code into namespaces so that equivalent symbols are actually different when fully qualified with their namespaces
** [[https://www.braveclojure.com/organization/#Creating_and_Switching_to_Namespaces][Creating and Switching to Namespaces]]
   * src_clojure{create-ns} returns a namespace identified by a given symbol
     * Not used often because it does not switch to the created namespace
   * src_clojure{in-ns} returns a namespace identified by a given symbol and switches to it
   * Fully qualified symbols begin with their namespace name
     * src_clojure{namespace/name} is the general format for a fully qualified symbol
     * Symbols from other namespaces must either be referred or fully qualified to be used
*** [[https://www.braveclojure.com/organization/#refer][refer]]
    * src_clojure{refer} updates the map of the current namespace to include symbols from a namespace identified by a given symbol
      * Eliminates the need for fully qualified symbols
      * Passing the src_clojure{:only} filter and a vector of symbols only refers mappings with the given symbols
      * Passing the src_clojure{:exclude} filter and a vector of symbols refers every mapping except those with the given symbols
      * Passing the src_clojure{:rename} filter and a map of symbols to symbols refers every mapping with any specified renaming applied
    * src_clojure{clojure.core/refer-clojure} refers everything in the src_clojure{clojure.core} namespace into the current namespace
    * src_clojure{defn-} creates a private function that cannot be referred to from other namespaces
      * src_clojure{@#'namespace/name} functions as a workaround but should scarcely be used if at all
*** [[https://www.braveclojure.com/organization/#alias][alias]]
    * src_clojure{alias} takes two symbols and aliases the second (a namespace) as the first
** [[https://www.braveclojure.com/organization/#Real_Project_Organization][Real Project Organization]]
*** [[https://www.braveclojure.com/organization/#The_Relationship_Between_File_Paths_and_Namespace_Names][The Relationship Between File Paths and Namespaces Names]]
    * The source code root directory is /src/
    * A dash in a namespace name corresponds to an underscore in a file or directory name
    * A period in a namespace name corresponds to a directory separator
    * The last component of a namespace corresponds to a Clojure filename
*** [[https://www.braveclojure.com/organization/#Requiring_and_Using_Namespaces][Requiring and Using Namespaces]]
    * src_clojure{require} takes a symbol identifying a namespace and evaluates the associated file so that its namespace is available for use
      * The file should declare a corresponding namespace
#+BEGIN_SRC clojure
(require '[namespace :as alias])
#+END_SRC
      * A vector can be passed with params, such as src_clojure{:as} for aliasing namespaces
      * src_clojure{use} is shorthand for src_clojure{require} and src_clojure{refer} but it is discouraged in production code for ambiguity reasons
        * This function can also take a vector with params, such as for aliasing a namespace in addition to the normal functionality
*** [[https://www.braveclojure.com/organization/#The_ns_Macro][The ns Macro]]
    * src_clojure{ns} covers the functionality of the aforementioned functions, which are usually only used in REPL mode
    * src_clojure{ns} implicitly refers src_clojure{clojure.core}
    * Symbols need not be quoted when used in src_clojure{ns}
    * src_clojure{ns} takes six different references that specify behavior
#+BEGIN_SRC clojure
(ns namespace.core
  (:refer-clojure :exclude [println]))
#+END_SRC
      * Use the src_clojure{:refer-clojure} reference to choose what is imported and how (just like src_clojure{refer})
      * Use the src_clojure{:require} reference just like the src_clojure{require} function
#+BEGIN_SRC clojure
(ns namespace.core
  (:require lib1 lib2))

(ns namespace.core
  (:require [lib1 :as a] [lib2 :as b]))
#+END_SRC
        * Multiple libraries can be required
#+BEGIN_SRC clojure
(ns namespace.core
  (:require [lib1 :refer [foo]]))

(ns namespace.core
  (:require [lib1 :refer :all]))
#+END_SRC
        * Symbols can be referred from a namespace
        * The src_clojure{:use} reference behaves just like the src_clojure{use} function
#+BEGIN_SRC clojure
(ns namespace.core
  (:use [base foo bar]))
#+END_SRC
          * Passing a vector results in the first element acting as a base namespace whilie subsequent elements, when appended to the base, form a full namespace
** [[https://www.braveclojure.com/organization/#To_Catch_a_Burglar][To Catch a Burglar]]
   * src_clojure{zipmap} returns a map where the key-value pairs come from two passed sequences
   * src_clojure{merge-width} takes a function and any number of maps, merging them together
     * If there are duplicate keys, the function is invoked with values from the maps (left to right order) to produce a new value
#+BEGIN_SRC clojure
(merge-width - {:a 1 :b 2} {:a 3 :b 4} {:a 5 :b 6}) ; => {:a -7 :b -8}
#+END_SRC
   * src_clojure{->} takes an expression and any number of forms, recursively threading the expr as the second item in each successive form
   * src_clojure{->>} takes an expression and any number of forms, recursively threading the expr as the last item in each successive form
   * src_clojure{spit} is the opposite of src_clojure{slurp} - it takes a filename and string and puts the string into the file
* [[https://www.braveclojure.com/read-and-eval/][Clojure Alchemy: Reading, Evaluation, and Macros]]
** [[https://www.braveclojure.com/read-and-eval/#An_Overview_of_Clojure_s_Evaluation_Model][An Overview of Clojure's Evaluation Model]]
   * Lisps use dual-phase evaluation models
     * Read input text and produce native data structures
     * Evaluate the produced data structures by traversing them
   * /Homoiconic/ languages treat their code as data and allow it to be manipulated in the same way
   * In Lisps, the abstract syntax tree of the code is represented via Lisp's native lists
     * Each tree is a list (and a nested tree is a nested list) and each value is a node
     * The first element is the tree's root and the other elements are branches
   * The Lisp reader and evaluator are separate so programmers can pass input directly to the evaluator without the reader
   * src_clojure{eval} evaluates a given data structure
   * Macros allow programmatic modification of code by treating it as data
** [[https://www.braveclojure.com/read-and-eval/#The_Reader][The Reader]]
   * Converts textual source code, representing data structures, /into/ those data structures
*** [[https://www.braveclojure.com/read-and-eval/#Reading][Reading]]
    * /Reader forms/ are the textual representations of data structures
    * The reader takes a reader form and returns the data structure it represents
    * src_clojure{read_string} processes a string reader form and returns a data structure
    * Many reader forms map one-to-one to what they represent, unless reader macros are used
*** [[https://www.braveclojure.com/read-and-eval/#Reader_Macros][Reader Macros]]
    * /Reader macros/ transform reader forms into data structures
      * Often allow reader forms to be more compact than their full forms
      * Marked by /macro characters/, such as src_clojure{'}, src_clojure{#}, and src_clojure{@}
    * src_clojure{'form} expands to src_clojure{(quote form)}
    * src_clojure{@form} expands to src_clojure{(deref form)}
    * src_clojure{;} is a reader macro that allows single-line comments by ignoring anything following it on the same line
    * Anonymous functions are enabled by reader macros
** [[https://www.braveclojure.com/read-and-eval/#The_Evaluator][The Evaluator]]
   * Evaluates data structures representing code
     * Symbols are evaluated to what they refer to
     * Lists are evaluated by invoking the first element as a function with the rest of the elements passed as arguments
     * All other values evaluate to themselves
*** [[https://www.braveclojure.com/read-and-eval/#These_Things_Evaluate_to_Themselves][These Things Evaluate to Themselves]]
    * Anything that isn't a list or symbol evaluates to itself
    * The empty list evaluates to itself
*** [[https://www.braveclojure.com/read-and-eval/#Symbols][Symbols]]
    * Symbols give names to anything and are evaluted by being resolved (to what they refer to)
    * Clojure checks if a symbol refers to a special form, a local binding, or a global binding
      * If no binding is found, an exception is thrown
    * To resolve a special form, it must be the first element of a list, otherwise an exception will be thrown
    * Local bindings are any symbol-value associations not made with src_clojure{def}, such as with src_clojure{let} or function definitions
    * Symbols and what they refer to do nothing without Clojure evaluating lists
*** [[https://www.braveclojure.com/read-and-eval/#Lists][Lists]]
    * The empty list evaluates to itself while all other lists are evaluted by calling the first element
**** [[https://www.braveclojure.com/read-and-eval/#Function_Calls][Function Calls]]
     * All operands are first fully evaluated before being passed as arguments
**** [[https://www.braveclojure.com/read-and-eval/#Special_Forms][Special Forms]]
     * Particular operands may or may not be evaluated depending on the special form
     * The src_clojure{quote} special form tells the evaluator to yield an unevaluated data structure
*** [[https://www.braveclojure.com/read-and-eval/#Macros][Macros]]
    * Macros are invoked between the reader and evaluator, allowing programmers to essentially manipulate the Clojure AST
    * src_clojure{defmacro} takes a data structure and returns a processed one suitable for the evaluator
    * Macro expansion is the process a macro takes to determine its return value
    * src_clojure{macro} takes a list that uses a macro and returns the unevaluated data structure returned by the macro
    * Macros can manipulate arbitrary data structures into evaluatable ones, allowing the use of Clojure to extend itself via syntactic abstraction
    * A macro expansion phase can be thought of as existing between reading and evaluating
*** [[https://www.braveclojure.com/read-and-eval/#Syntactic_Abstraction_and_the____Macro][Syntactic Abstraction and the -> Macro]]
    * src_clojure{->}, the threading (or "stabby") macro, makes code readable from top-to-bottom and left-to-right as opposed to right-to-left
      * It expresses nested function calls as a pipeline
* [[https://www.braveclojure.com/writing-macros/][Writing Macros]]
** [[https://www.braveclojure.com/writing-macros/#Macros_are_Essential][Macros are Essential]]
   * Used to create much of Clojure's built-in functionality
     * src_clojure{when} is a macro that essentially combines src_clojure{if} and src_clojure{do}
** [[https://www.braveclojure.com/writing-macros/#Anatomy_of_a_Macro][Anatomy of a Macro]]
   * Macro definitions look equivalent to function definitions
   * Like functions, macros can use rest arguments and argument destructuring, can have multiple arities, can use recursion, and can use any function, macro, or special form
   * Macros usually return lists that will later be evaluated
   * Arguments to macros are unevaluated - the expectation is that they will be manipulated into a data structure that can be evaluated
** [[https://www.braveclojure.com/writing-macros/#Building_Lists_for_Evaluation][Building Lists for Evaluation]]
   * Macros are meant to create lists for eventual evaluation so quoting is often necessary to delay evaluation
*** [[https://www.braveclojure.com/writing-macros/#Distinguishing_Symbols_and_Values][Distinguishing Symbols and Values]]
    * Quoting is necessary for the returned list to contain an unresolved symbol instead of its value (or in any case where evaluation needs to be turned off)
      * Otherwise Clojure may attempt to evaluate unbound symbols or prematurely retrieve the value of a symbol
*** [[https://www.braveclojure.com/writing-macros/#Simple_Quoting][Simple Quoting]]
    * src_clojure{quote} prevents its argument from being evaluated
    * src_clojure{'} is a reader macro for src_clojure{quote}
    * Quoting a symbol, whether associated with a value or not, prevents its evaluation
*** [[https://www.braveclojure.com/writing-macros/#Syntax_Quoting][Syntax Quoting]]
    * Simple quoting and the src_clojure{list} function can lead to verbose code, so the syntax quote src_clojure{`} is often better
    * Syntax quoting yields fully qualified symbols, preventing namespace collisions
    * Syntax quoting is recursive just like simple quoting
    * Syntax quoting can be undone with src_clojure{~} which leads to a form that was syntax quoted being evaluted
    * Syntax quoting and unquoting leads to code that is clearer, conciser, and closer to the resultant forms than with simple quoting
** [[https://www.braveclojure.com/writing-macros/#Using_Syntax_Quoting_in_a_Macro][Using Syntax Quoting in a Macro]]
   * Syntax quoting simplifies cases where most forms should be quoted and only some should be evaluated
   * If multiple forms need to be evaluated, wrap them in src_clojure{do}
** [[https://www.braveclojure.com/writing-macros/#Refactoring_a_Macro_and_Unquote_Splicing][Refactoring a Macro and Unquote Splicing]]
   * Unquote splicing unwraps the contents of a sequence into the enclosing syntax-quoted data structure
     * Useful for unwraping a sequence of forms
   * src_clojure{~@seq} unquote splices the given sequence
** [[https://www.braveclojure.com/writing-macros/#Things_to_Watch_Out_For][Things to Watch Out For]]
*** [[https://www.braveclojure.com/writing-macros/#Variable_Capture][Variable Capture]]
    * Occurs when macros create variable bindings that override existing ones
    * Can be prevented by syntax quoting - an exception is thrown when creating a let-binding because syntax quoting creates fully qualified names
    * src_clojure{gensym} creates unique symbols with an optional supplied prefix
#+BEGIN_SRC clojure
(defmacro foo
  [& forms]
  (let [msg (gensym 'msg)]
    `(let [~msg "goodbye, world!"]
       ~@forms
       (println ~msg))))
#+END_SRC
    * src_clojure{sym#} creates an auto-gensym, and every instance of src_clojure{sym#} will evaluate to the same symbol
#+BEGIN_SRC clojure
(defmacro foo
  [& forms]
  `(let [msg# "goodbye, world!"]
     ~@forms
     (println msg#)))
#+END_SRC
*** [[https://www.braveclojure.com/writing-macros/#Double_Evaluation][Double Evaluation]]
    * Sometimes a form passed to a macro will be evaluated multiple times
    * Store the return value of a form to avoid double evaluation
*** [[https://www.braveclojure.com/writing-macros/#Macros_All_the_Way_Down][Macros All the Way Down]]
    * Creating and using macros is often an endless cycle because macros occur before evaluation
    * Macros compose best with other macros and less so with functions
    * If the only way to properly use a macro is to create many others, the approach may be wrong
** [[https://www.braveclojure.com/writing-macros/#Brews_for_the_Brave_and_True][Brews for the Brave and True]]
*** [[https://www.braveclojure.com/writing-macros/#Validation_Functions][Validation Functions]]
*** [[https://www.braveclojure.com/writing-macros/#if_valid][if-valid]]
* [[https://www.braveclojure.com/concurrency/][The Sacred Art of Concurrent and Parallel Programming]]
** [[https://www.braveclojure.com/concurrency/#Concurrency_and_Parallelism_Concepts][Concurrency and Parallelism Concepts]]
*** [[https://www.braveclojure.com/concurrency/#Managing_Multiple_Tasks_vs__Executing_Tasks_Simultaneously][Managing Multiple Tasks vs. Executing Tasks Simultaneously]]
    * Concurrency is the simultaneous management of multiple tasks
    * Parallelism is the simultaneous execution of multiple tasks and is a subtype of concurrency
    * Distributed computing is a type of parallelism where tasks are executed on different computers on a network
*** [[https://www.braveclojure.com/concurrency/#Blocking_and_Asynchronous_Tasks][Blocking and Asynchronous Tasks]]
    * If a task blocks, then tasks are executed synchronously and nothing else executes until that task finishes
    * If a task does not block, then tasks are executed asychronously and other code can execute while that task finishes
*** [[https://www.braveclojure.com/concurrency/#Concurrent_Programming_and_Parallel_Programming][Concurrent Programming and Parallel Programming]]
    * Concurrent and parallel programming are methodologies for turning one task into subtasks that can be executed in parallel as well as managing the associated risks
** [[https://www.braveclojure.com/concurrency/#Clojure_Implementation__JVM_Threads][Clojure Implementation: JVM Threads]]
*** [[https://www.braveclojure.com/concurrency/#What_s_a_Thread_][What's a Thread?]]
    * Threads are like subprograms, wherein each executes code and can access and manipulate shared state
    * Threads can be implemented at numerous levels in the execution hierarchy, often at levels as low as the kernel
    * Threads can spawn new threads for concurrent execution
      * Threads are interleaved on single-core systems - execution switches between the threads, though there is no guarantee on when the switch occurs, making the program nondeterministic
      * Multi-core systems execute one thread on each core without interleaving, though again no guarantees are made about execution order so the program is still nondeterministic
*** [[https://www.braveclojure.com/concurrency/#The_Three_Goblins__Reference_Cells__Mutual_Exclusion__and_Dwarven_Berserkers][The Three Goblins: Reference Cells, Mutual Exclusion, and Dwarven Berserkers]]
    * The reference cell problem is when multiple threads have read/write access to a location and the value at this location depends on the order in which the threads read and write
    * Mutual exclusion is a method to prevent race conditions, where the resultant behavior of a program changes based on thread execution order
    * A deadlock is when two threads wait for each other to finish their tasks before continuing with their own
      * The "dining philosophers problem" is a common example of this
** [[https://www.braveclojure.com/concurrency/#Futures__Delays__and_Promises][Futures, Delays, and Promises]]
   * Serial code conjoins the definition of a task, its execution, and the acquiring of its result together when, in reality, they can often occur at entirely different times
*** [[https://www.braveclojure.com/concurrency/#Futures][Futures]]
    * Futures allow tasks to be executed on separate threads and for the result to be requested at a separate time
      * Results are cached and the task executes only once
      * The result does not have to be dereferenced - futures can be used for side-effecting asynchronous tasks
    * The src_clojure{future} macro takes forms to evaluate and returns a future whose value can later be dereferenced with src_clojure{deref} or the src_clojure{@} reader macro
    * Dereferencing a future's value blocks, though a time limit and default value can be passed to src_clojure{deref} if necessary
    * src_clojure{realized?} returns whether or not a given future has finished executing
*** [[https://www.braveclojure.com/concurrency/#Delays][Delays]]
    * Delays allow tasks to be defined without immediately executing or returning a value
      * Once the task executes, the value is cached and the tasks are never executed again
    * The src_clojure{delay} macro creates a delay from a list of forms to evaluate, which will be evaluated when the delay is first dereferenced
    * src_clojure{force} causes a given delay to be executed and returns its value, just like derefencing it
    * Delays can ensure some particular code is evaluated only when first necessary and only once
*** [[https://www.braveclojure.com/concurrency/#Promises][Promises]]
    * Promises allow one to express that a result is expected without defining what task will produce that result nor executing it
    * src_clojure{promise} creates a new promise
    * src_clojure{deliver} delivers to a given promise a given value
    * Dereferencing a promise blocks until a value is delivered to it
    * Since delivery can occur only once, the reference cell issue is prevented
    * Promises are useful as callbacks as a promise can be delivered a return value from outside code
*** [[https://www.braveclojure.com/concurrency/#Rolling_Your_Own_Queue][Rolling Your Own Queue]]
    * When multiple tasks access a shared resource, every portion of the tasks not using the resource can be executed in parallel while the resource-acccess portions are queued and executed serially
* [[https://www.braveclojure.com/zombie-metaphysics/][Clojure Metaphysics: Atoms, Refs, Vars, and Cuddle Zombies]]
** [[https://www.braveclojure.com/zombie-metaphysics/#Object_Oriented_Metaphysics][Object-Oriented Metaphysics]]
   * OOP objects may have mutable properties but are always treated as the same object
     * This opens them up to nondeterminism if tasks using the object are run concurrently
     * Objects may also be in inconsistent/invalid states when in the middle of an update, requring mutexes to prevent such issues
   * Objects perform tasks and change state throughout time
** [[https://www.braveclojure.com/zombie-metaphysics/#Clojure_Metaphysics][Clojure Metaphysics]]
   * Clojure deals with successions of atomic (indivisible/basic and immutable) values that are derived with processes
   * Identity is given to a series of values rather than to a mutable object
     * State is not mutable, it refers to the value of an identity at some point in time
     * Information does not change, rather, new information is created
   * Values do not do anything - they are simply used to derive new ones
   * Reference types manage identities, which refer to various states over time
** [[https://www.braveclojure.com/zombie-metaphysics/#Atoms][Atoms]]
   * src_clojure{atom} creates a new atom, initialized with a given value
   * Atoms do not block when dereferenced - they already have a value
     * Since the returned value is immutable, concurrent writes to the atom after a value is retrieved are not an issue
   * src_clojure{swap!} synchronously updates the value a given atom refers to  via a given function and some optional additional arguments
     * Inconsistent state can be prevented simply by updating everything all at once
   * If concurrent attempts at swapping an atom's value are made, any possible issues are prevented by the compare and set algorithm employed
     * Read the current state
     * Create a new value
     * Check if the current state is the same as the last read state
     * If so, write the new value
     * If not, retry
   * src_clojure{reset!} changes the value of an atom to a given value
** [[https://www.braveclojure.com/zombie-metaphysics/#Watches_and_Validators][Watches and Validators]]
*** [[https://www.braveclojure.com/zombie-metaphysics/#Watches][Watches]]
    * Watches monitor all changes made to atoms
    * Watch functions take an identifier key, the watched reference, the previous state of the reference, and the new state of the reference and are invoked every time a reference changes its state
    * src_clojure{add-watch} adds to a given atom a given key associated with a given watch function
*** [[https://www.braveclojure.com/zombie-metaphysics/#Validators][Validators]]
    * Validators determine whether or not a state is permissible gor a given particular reference
    * Validator functions return a boolean or throw/don't throw an exception based on whether a given possible new state for a reference is valid or not
#+BEGIN_SRC clojure
(atom 0 :validator even?)
#+END_SRC
    * Creates a new atom, intialized with the value 0, and attaches the src_clojure{even?} function as a validator
    * Before a reference is given a new value, its validator will be invoked
    * Atoms are great for independent identities but refs can be used for simultaneously updating related identities
*** [[https://www.braveclojure.com/zombie-metaphysics/#Modeling_Sock_Transfers][Modeling Sock Transfers]]
    * Refs use transaction semantics to update the state of multiple identities at once
      * Transactions are atomic, updating all refs or none, consistent, meaning all refs always have valid states, and isolated, meaning transactions will retry in a manner similar to compare and set semantics
      * Transactions are implemented with software transactional memory
    * src_clojure{ref} creates a new reference with a given value
    * src_clojure{dosync} initiates a transaction, in which src_clojure{alter} can be used to update a ref
    * Ref value changes are not visible outside of a transaction until it completes
*** [[https://www.braveclojure.com/zombie-metaphysics/#commute][commute]]
    * src_clojure{commute} behaves identically to src_clojure{alter}, except there are no compare and set semantics and thus it should only be used when there is no chance of concurrent sets
    * Commuting values can be more performant but also dangerous and prone to write skew issues
** [[https://www.braveclojure.com/zombie-metaphysics/#Vars][Vars]]
   * Vars associate symbols to objects and are created with src_clojure{def}
*** [[https://www.braveclojure.com/zombie-metaphysics/#Dynamic_Binding][Dynamic Binding]]
    * The value of a /dynamic/ var can be changed, which is useful for global names with different values depending on the context
**** [[https://www.braveclojure.com/zombie-metaphysics/#Creating_and_Binding_Dynamic_Vars][Creating and Binding Dynamic Vars]]
     * Symbols for dynamic vars are, by convention, surrounded with asterisks ("earmuffs")
     * To make a var dynamic, set the dynamic property in its metadata to true
#+BEGIN_SRC clojure
(def ^:dynamic foo :bar)
#+END_SRC
     * Creates a new var and makes it dynamic via shorthand metadata syntax for flags
     * Dynamic vars can be contextually rebound (with scopes) with src_clojure{binding}
**** [[https://www.braveclojure.com/zombie-metaphysics/#Dynamic_Var_Uses][Dynamic Var Uses]]
     * Function parameters could often be used instead of dynamic vars but dynamic vars are useful when many functions use the same resource
       * src_clojure{*out*} is a dynamic var for the standard output stream, which could be temporarily rebound to a file to print to it
     * Dynamic vars are useful for configuration, such as the src_clojure{*print-length*} var to limit the number of items in a collection that are printed
     * src_clojure{set!} takes a symbol for a thread-bound dynamic var and sets it to a given value in the context of the binding
     * src_clojure{thread-bound?} tells whether or not a given var is thread bound
**** [[https://www.braveclojure.com/zombie-metaphysics/#Per_Thread_Binding][Per-Thread Binding]]
     * Bindings are per-thread and are not conveyed into manually created threads, so new threads will not implicitly have the bindings of the original thread
       * Futures implicitly have bindings conveyed into them
       * The REPL rebinds src_clojure{*out*} but in manually created threads it will refer to stdout
       * src_clojure{bound-fn} takes a function and returns a new one with the current thread bindings in effect
*** [[https://www.braveclojure.com/zombie-metaphysics/#Altering_the_Var_Root][Altering the Var Root]]
    * Vars are created with an initial value as their root, which serves as their default value in threads without a per-thread binding
    * src_clojure{alter-var-root} takes a var and an updater function and changes the given var's root
    * src_clojure{with-redefs} works like src_clojure{bindings}, temporarily changing the var root of any var
** [[https://www.braveclojure.com/zombie-metaphysics/#Stateless_Concurrency_and_Parallelism_with_pmap][Stateless Concurrency and Parallelism with pmap]]
   * Many tasks, such as deriving new values when mapping over a collection, are completely independent of each other and can run concurrently without any risks
   * src_clojure{pmap} is identical to src_clojure{map}, except it runs each iteration in parallel
   * src_clojure{repeatedly} creates an infinite lazy sequence from a given function
   * Inherent overhead exists from creating and managing threads, which makes src_clojure{pmap} slower than src_clojure{map} in some cases
     * Increasing the /grain size/, the amount of work done by each parallel task, solves this issue
       * For mapping, partition the collection, map each partition in a task, and concatenate the new partitions at the end
   * src_clojure{partition} splits a given collection into smaller collections of a given size, discarding the last elements if they would yield a collection smaller than the given size
   * src_clojure{partition-all} works like src_clojure{partition} but keeps all elements, so the last subcollection may be smaller than the given size
   * src_clojure{doall} realizes a lazy sequence and returns it
   * src_clojure{dorun} realizes a lazy sequence but returns src_clojure{nil}
   * The clojure.core.reducers library provides alternative seq function implementations that are often faster but are not lazy
* [[https://www.braveclojure.com/core-async/][Mastering Concurrent Processes with core.async]]
** [[https://www.braveclojure.com/core-async/#Getting_Started_with_Processes][Getting Started with Processes]]
   * Processes are concurrent tasks that respond to events
     * Differ from tasks that are fired and forgotten or are only part of the main task
   * src_clojure{chan} creates a new channel, which is used for message passing between processes
   * Processes wait for their put (message) and take (message) operations to succeed before continuing execution
     * A process that /put/ a message waits for another process to /take/ that message before continuing
   * src_clojure{go} creates a /go block/, which defines a process, and runs it on another thread
   * src_clojure{<!} reads a value from a given channel (it is a /take/ operation)
   * src_clojure{>!!} writes to a given channel a given message (it is a /put/ operation}
*** [[https://www.braveclojure.com/core-async/#Buffering][Buffering]]
    * Channels can be buffered so multiple messages can be passed to them without blocking
    * Passing a number to src_clojure{chan} creates a channel that can hold that number of messages without blocking
      * If a process puts on any more messages, it will wait until all messages can fit in the channel
    * src_clojure{sliding-buffer} creates a buffer that drops messages (FIFO) and does not block
    * src_clojure{dropping-buffer} creates a buffer that drops messages (LIFO) and does not block
*** [[https://www.braveclojure.com/core-async/#Blocking_and_Parking_][Blocking and Parking]]
    * Processes can wait by either blocking or parking
    * A process that blocks stops executing and will block whatever thread it is on
    * A process that parks stops executing but does not necessarily block whatever thread it is on - if another process is available, it will be run on the thread until it blocks or parks
    * A single exclamation mark indicates a parking operation while a double exclamation mark indicates a blocking operation
      * Parking can only be used inside src_clojure{go} blocks whereas blocking can be used anywhere
*** [[https://www.braveclojure.com/core-async/#thread][thread]]
    * src_clojure{thread} is similar to src_clojure{future}
      * Creates a new thread and executes given code, returning a new channel that will eventually store the process' return value
      * Should be used when blocking is necessary (e.g. the process takes a long time before it puts or takes anything)
      * Avoids clogging the preexisting thread pool and allows the process to run when the preexisting thread pool is full
** [[https://www.braveclojure.com/core-async/#The_Hot_Dog_Machine_Process_You_ve_Been_Longing_For][The Hot Dog Machine Process You've Been Longing For]]
   * src_clojure{close!} closes a given channel
   * Combining /put/ and /take/ operations in one process makes it easy to create a pipeline
     * One process writes to a channel that serves as the input to another process
   * The waiting behavior of processes is state-like
     * For instasnce, when a process does a put operation with a value, another process must take it before another value can be created and put
     * As another example, a process may cycle through taking input, calculating a value, and outputting it
** [[https://www.braveclojure.com/core-async/#alts__][alts!!]]
   * src_clojure{alts!!} takes a vector of channels, performs a blocking /take/ with all of them, and returns a vector containing the first message to be received and the channel that /put/ it
     * If one element of the vector is another vector with a channel and a value, an attempt will be made to /put/ the value onto that channel
       * If this is the first successful operation and the channel was not closed, src_clojure{true} will be returned
   * src_clojure{timeout} creates a channel that times out after a given amount of milliseconds
     * Useful in combination with src_clojure{alts!!} - wait to retrieve a value up to a certain amount of time
   * src_clojure{alts!} also exists as a parking version
** [[https://www.braveclojure.com/core-async/#Queues][Queues]]
   * Simple queues can be made by spawning many processes that send values to another process that handles them in the order they were received
** [[https://www.braveclojure.com/core-async/#Escape_Callback_Hell_with_Process_Pipelines][Escape Callback Hell with Process Pipelines]]
   * Process pipelines can avoid callbacks by clearly defining isolated processes that need only interact with input and output channels
   * A function can be made to launch a looping process that reads from an input channel and writes to an output channel returned by the function
* [[https://www.braveclojure.com/java/][Working with the JVM]]
** [[https://www.braveclojure.com/java/#The_JVM][The JVM]]
   * Clojure programs run on the Java Virtual Machine, which  uses Just-in-Time compilation to translate JVM bytecode into CPU instructions executed by the host machine
     * Code is translated into JVM bytecode, which is then translated into CPU instructions at runtime
** [[https://www.braveclojure.com/java/#Writing__Compiling__and_Running_a_Java_Program][Writing, Compiling, and Running a Java Program]]
*** [[https://www.braveclojure.com/java/#Object_Oriented_Programming_in_the_World_s_Tiniest_Nutshell][Object-Oriented Programming in the World's Tiniest Nutshell]]
    * Java is an OOP language, which influences how Java code is written and how Clojure interops with Java code
    * Objects, as members of a class that define their structure, store data and execute methods
    * Classes can also execute methods
*** [[https://www.braveclojure.com/java/#Ahoy__World][Ahoy, World]]
    * When Java programs are compiled, /.class/ files are created for each class
    * When Java programs are run, a class containing the main function is fed to the JVM, which inspects the classpath for that class
** [[https://www.braveclojure.com/java/#Packages_and_Imports][Packages and Imports]]
   * A Java package is similar to a Clojure namespace in that it organizes code
     * Contains classes
     * Names correlate to filesystem paths
   * Importing a class is similar to referring a namespace - the class can be used without specifying its namespace
     * All members of a package can be imported with an asterisk
   * By default, the classpath upon which packages are looked up includes just the current working directory from which the JVM was invoked
** [[https://www.braveclojure.com/java/#JAR_Files][Jar Files]]
   * JAR files bundle /.class/ files together into an archive, which then be processed by the JVM
     * If a class with an entry point is specified and the JVM is told to run the JAR file as a program, that entry point will be executed
   * The default classpath in a JAR file is at its root and directory structure is preserved within, eliminating some classpath issues
** [[https://www.braveclojure.com/java/#clojure_jar][clojure.jar]]
   * The Clojure runtime initiates the REPL in its entry point in the ~clojure.main~ class
** [[https://www.braveclojure.com/java/#Clojure_App_JARs][Clojure App JARs]]
   * The src_clojure{(:gen-class)} directive used in namespace declarations causes a class file to be generated for the namespace
   * The src_clojure{-main} function in an entry point namespace becomes the main function invoked by the JVM
** [[https://www.braveclojure.com/java/#Java_Interop][Java Interop]]
   * Interop between Clojure and Java is very simple to ensure Clojure is highly practical
*** [[https://www.braveclojure.com/java/#Interop_Syntax][Interop Syntax]]
    * The src_clojure{.member} operator takes a receiver object and any additional arguments (if the member is a function to be invoked) to retrieve from or invoke the member upon the receiver
      * Uses macros to expand to use the src_clojure{.} special form
#+BEGIN_SRC clojure
(.length "hello") ; => 5
#+END_SRC
    * Static members can be retrieved with the same syntax with which Clojure namespace members are retrieved
      * Static methods can be invoked just like Clojure methods
*** [[https://www.braveclojure.com/java/#Creating_and_Mutating_Objects][Creating and Mutating Objects]]
    * Objects can be created with src_clojure{(Classname. args)} or src_clojure{(new Classname args)}, with the former often being preferred
    * src_clojure{doto} is a macro that takes a value, inserts it as the second element in the remaining forms, evaluates these forms in order, and returns the original value
#+BEGIN_SRC clojure
(doto (java.util.Stack.)
  (.push 0)
  (.push "one")) ; => [0 "one"]
#+END_SRC
*** [[https://www.braveclojure.com/java/#Importing][Importing]]
    * Importing is done with src_clojure{import} or the src_clojure{(:import)} directive in namespace declarations
    * Individual or multiple members from namespaces can be imported to avoid having to type entire package names
    * The members of the ~java.lang~ package are implicitly imported
** [[https://www.braveclojure.com/java/#Commonly_Used_Java_Classes][Commonly Used Java Classes]]
*** [[https://www.braveclojure.com/java/#The_System_Class][The System Class]]
    * The ~System~ class is useful for program environment interaction, such as with stdin, stdout, and stderr
    * src_clojure{System/exit} terminates the program with a status code
    * src_clojure{System/getenv} returns environment variables as a map, which is useful for program configuration
    * src_clojure{System/getProperty} can give JVM properties (separate from environment variables)
*** [[https://www.braveclojure.com/java/#The_Date_Class][The Date Class]]
    * The ~java.util.Date~ class is useful for dealing with time
    * The reader form for a date is src_clojure{#inst date-string}
    * The ~java.util.DateFormat~ class is useful for managing string <-> date conversions
** [[https://www.braveclojure.com/java/#Files_and_Input_Output][Files and Input/Output]]
   * The src_clojure{clojure.java.io} namespace greatly simplifies the Java IO interfaces
   * Java provides many classes for interfacing with files, sockets, buffers, and many other resources
   * Various types of reader and writer classes can be used with any resource, but the sheer amount of available classes can make the Java IO interfaces unwieldy
   * Clojure simplifies reading and writing with unified functions, such as src_clojure{slurp} and src_clojure{spit}, which work with any resource or reader/writer type
   * src_clojure{with-open} creates bindings to resources, evaluates forms that use them, then closes the resources in reverse order in order to simplify resource opening, reading, and closing
* [[https://www.braveclojure.com/multimethods-records-protocols/][Create and Extend Abstractions with Multimethods, Protocols, and Records]]
** [[https://www.braveclojure.com/multimethods-records-protocols/#Polymorphism][Polymorphism]]
   * Polymorphism is the association of an operation name with multiple implementations based on properties of the operands
   * Clojure provides /records/ and /types/ for creating new data types
*** [[https://www.braveclojure.com/multimethods-records-protocols/#Multimethods][Multimethods]]
    * Multimethods dispatch to different implementations based on properties of the operands
      * A dispatching function receives the arguments and returns a dispatching value
      * The chosen method, which receives the same arguments, is chosen if its dispatch value matches the dispatching value
#+BEGIN_SRC clojure
(defmulti foo class) ; class is the dispatching function
(defmethod foo java.lang.String [x] (str x " is a String!")) ; java.lang.String is the dispatch value for this method
(defmethod foo java.lang.Long [x] (str x " is a Long!"))
(defmethod foo :default [x] (str x " is something else!")) ; the default method (dispatch value is :default)

(foo "hello") ; => "hello is a String!"
#+END_SRC
    * Defines a new multimethod that dispatches on the class of the argument and has an implementation for Strings, Longs, and anything else
    * New methods can always be added, even from other namespaces, to extend the multimethod
    * Hierarchical dispatching can also be used, wherein methods are dispatched if operands are a member of a type or one of its subtypes
*** [[https://www.braveclojure.com/multimethods-records-protocols/#Protocols][Protocols]]
    * Multimethods can be used for type-based dispatching but protocols are better for this purpose
    * Multimethods are a single polymorphic operation whereas protocols are groups of polymorphic operations
    * Protocols define abstractions without their implementations
    * Protocols have methods which dispatch based on the type of their first argument
#+BEGIN_SRC clojure
(defprotocol Proto
  (foo [x])
  (bar [x y] [x y z]))

(extend-type java.lang.String Proto
  (foo [x] (str x x))
  (bar ([x y] (str x y x y)) ([x y z] (str x y z x y z))))

(foo "hello") ; => "hellohello"
(bar "hello" "world") ; => "helloworldhelloworld"
(bar "hello" "cruel" "world") ; => "hellocruelworldhellocruelworld"
#+END_SRC
    * Defines a new protocol named ~Proto~ with ~foo~ and ~bar~ methods and implements it for the ~java.lang.String~ type
    * Protocol methods can have multiple arities but they cannot use rest args
    * Default implementations can be mocked by implementing the protocol for ~java.lang.Object~, since that is the root type of all types
    * src_clojure{extend-protocol} simplifies creating multiple protocol implementations by taking the protocol name followed by a type and methods for that type ad infinitum
    * Protocol methods are part of the namespace in which they are defined (e.g. a method src_clojure{foo} defined in src_clojure{bar} has the fully qualified name src_clojure{bar/foo}
** [[https://www.braveclojure.com/multimethods-records-protocols/#Records][Records]]
   * Records are similar to maps in that they associate keys with values and are immutable
   * Records specify allowable fields, as if defining what keys are allowed in a map, and can implement protocols
#+BEGIN_SRC clojure
(defrecord Foo [bar baz])
#+END_SRC
   * Defines a new record
   * Records can be created with src_clojure{Name.}, src_clojure{->Name}, or src_clojure{map->Name}
     * The first two take arguments for the fields in order while the latter takes a map where the keys are keywords for field names
   * Fields can be accessed with keywords representing field names
   * Functions that work on maps also work on records, although records are more performant than maps
   * Records are implemented as Java classes, which means
     * They are imported as Java classes, so dashes in their namespace names become underscores
     * They can be instantiated like Java classes
     * Fields can be accessed with Java interop syntax
   * Records can implement protocols by taking a protocol name and method implementations after the field declarations, or with src_clojure{extend-type} and src_clojure{extend-protocol}
* [[https://www.braveclojure.com/appendix-a/][Building and Developing with Leiningen]]
** [[https://www.braveclojure.com/appendix-a/#The_Artifact_Ecosystem][The Artifact Ecosystem]]
   * Clojure programs are distributed as JARs and Clojure artifact tools work similarly to Maven
*** [[https://www.braveclojure.com/appendix-a/#Identification][Identification]]
    * Artifacts bear a group ID, an artifact ID, and a version number
    * In the ~project.clj~ file, src_clojure{defproject} first takes a symbol used for both the group and artifact ID and a string version number
      * If the symbol contains a ~/~, the first part is the group ID and the second part is the artifact ID
      * Version numbers are practically permanent - if an artifact is uploaded with a version number, it should not be replaced with a different artifact
*** [[https://www.braveclojure.com/appendix-a/#Dependencies][Dependencies]]
    * The src_clojure {:dependencies} directive in project definitions allows specification of project dependencies
    * Many Clojure artifacts are hosted on Clojars and Maven Central
    * src_sh{lein deploy clojars} creates the necessary files for uploading a Maven artifact
*** [[https://www.braveclojure.com/appendix-a/#Plug_Ins][Plug-Ins]]
    * Plugins can be added to Leiningen to assist in any part of the programming process
* [[https://www.braveclojure.com/appendix-b/][Boot, the Fancy Clojure Build Framework]]
** [[https://www.braveclojure.com/appendix-b/#Boot_s_Abstractions][Boot's Abstractions]]
** [[https://www.braveclojure.com/appendix-b/#Tasks][Tasks]]
** [[https://www.braveclojure.com/appendix-b/#The_REPL][The REPL]]
** [[https://www.braveclojure.com/appendix-b/#Composition_and_Coordination][Composition and Coordination]]
*** [[https://www.braveclojure.com/appendix-b/#Handlers_and_Middleware][Handlers and Middleware]]
*** [[https://www.braveclojure.com/appendix-b/#Tasks_Are_Middleware_Factories][Tasks Are Middleware Factories]]
** [[https://www.braveclojure.com/appendix-b/#Filesets][Filesets]]
